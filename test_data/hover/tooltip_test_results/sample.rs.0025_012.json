{
  "test": {
    "file": "sample.rs",
    "line": 25,
    "col": 12
  },
  "data": {
    "Ok": [
      "Overloadable operators.\n\nImplementing these traits allows you to overload certain operators.\n\nSome of these traits are imported by the prelude, so they are available in\nevery Rust program. Only operators backed by traits can be overloaded. For\nexample, the addition operator (`+`) can be overloaded through the [`Add`]\ntrait, but since the assignment operator (`=`) has no backing trait, there\nis no way of overloading its semantics. Additionally, this module does not\nprovide any mechanism to create new operators. If traitless overloading or\ncustom operators are required, you should look toward macros or compiler\nplugins to extend Rust's syntax.\n\nImplementations of operator traits should be unsurprising in their\nrespective contexts, keeping in mind their usual meanings and\n[operator precedence]. For example, when implementing [`Mul`], the operation\nshould have some resemblance to multiplication (and share expected\nproperties like associativity).\n\nNote that the `&&` and `||` operators short-circuit, i.e. they only\nevaluate their second operand if it contributes to the result. Since this\nbehavior is not enforceable by traits, `&&` and `||` are not supported as\noverloadable operators.\n\nMany of the operators take their operands by value. In non-generic\ncontexts involving built-in types, this is usually not a problem.\nHowever, using these operators in generic code, requires some\nattention if values have to be reused as opposed to letting the operators\nconsume them. One option is to occasionally use [`clone`].\nAnother option is to rely on the types involved providing additional\noperator implementations for references. For example, for a user-defined\ntype `T` which is supposed to support addition, it is probably a good\nidea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n[`Add<&T>`][`Add`] so that generic code can be written without unnecessary\ncloning.\n\n# Examples\n\nThis example creates a `Point` struct that implements [`Add`] and [`Sub`],\nand then demonstrates adding and subtracting two `Point`s.\n\n```rust\nuse std::ops::{Add, Sub};\n\n#[derive(Debug, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -> Point {\n        Point {x: self.x + other.x, y: self.y + other.y}\n    }\n}\n\nimpl Sub for Point {\n    type Output = Point;\n\n    fn sub(self, other: Point) -> Point {\n        Point {x: self.x - other.x, y: self.y - other.y}\n    }\n}\n\nassert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\nassert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n```\n\nSee the documentation for each trait for an example implementation.\n\nThe [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\ninvoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\nself` and [`FnOnce`] takes `self`. These correspond to the three kinds of\nmethods that can be invoked on an instance: call-by-reference,\ncall-by-mutable-reference, and call-by-value. The most common use of these\ntraits is to act as bounds to higher-level functions that take functions or\nclosures as arguments.\n\nTaking a [`Fn`] as a parameter:\n\n```rust\nfn call_with_one<F>(func: F) -> usize\n    where F: Fn(usize) -> usize\n{\n    func(1)\n}\n\nlet double = |x| x * 2;\nassert_eq!(call_with_one(double), 2);\n```\n\nTaking a [`FnMut`] as a parameter:\n\n```rust\nfn do_twice<F>(mut func: F)\n    where F: FnMut()\n{\n    func();\n    func();\n}\n\nlet mut x: usize = 1;\n{\n    let add_two_to_x = || x += 2;\n    do_twice(add_two_to_x);\n}\n\nassert_eq!(x, 5);\n```\n\nTaking a [`FnOnce`] as a parameter:\n\n```rust\nfn consume_with_relish<F>(func: F)\n    where F: FnOnce() -> String\n{\n    // `func` consumes its captured variables, so it cannot be run more\n    // than once\n    println!(\"Consumed: {}\", func());\n\n    println!(\"Delicious!\");\n\n    // Attempting to invoke `func()` again will throw a `use of moved\n    // value` error for `func`\n}\n\nlet x = String::from(\"x\");\nlet consume_and_return_x = move || x;\nconsume_with_relish(consume_and_return_x);\n\n// `consume_and_return_x` can no longer be invoked at this point\n```\n\n[`Fn`]: trait.Fn.html\n[`FnMut`]: trait.FnMut.html\n[`FnOnce`]: trait.FnOnce.html\n[`Add`]: trait.Add.html\n[`Sub`]: trait.Sub.html\n[`Mul`]: trait.Mul.html\n[`clone`]: ../clone/trait.Clone.html#tymethod.clone\n[operator precedence]: ../../reference/expressions.html#expression-precedence"
    ]
  }
}