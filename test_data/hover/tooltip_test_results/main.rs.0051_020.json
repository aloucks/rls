{
  "test": {
    "file": "main.rs",
    "line": 51,
    "col": 20
  },
  "data": {
    "Ok": [
      {
        "language": "rust",
        "value": "pub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,"
      },
      "https://doc.rust-lang.org/nightly/std/thread/spawn.v.html",
      "Spawns a new thread, returning a [`JoinHandle`] for it.\n\nThe join handle will implicitly *detach* the child thread upon being\ndropped. In this case, the child thread may outlive the parent (unless\nthe parent thread is the main thread; the whole process is terminated when\nthe main thread finishes). Additionally, the join handle provides a [`join`]\nmethod that can be used to join the child thread. If the child thread\npanics, [`join`] will return an [`Err`] containing the argument given to\n[`panic`].\n\nThis will create a thread using default parameters of [`Builder`], if you\nwant to specify the stack size or the name of the thread, use this API\ninstead.\n\nAs you can see in the signature of `spawn` there are two constraints on\nboth the closure given to `spawn` and its return value, let's explain them:\n\n- The `'static` constraint means that the closure and its return value\n  must have a lifetime of the whole program execution. The reason for this\n  is that threads can `detach` and outlive the lifetime they have been\n  created in.\n  Indeed if the thread, and by extension its return value, can outlive their\n  caller, we need to make sure that they will be valid afterwards, and since\n  we *can't* know when it will return we need to have them valid as long as\n  possible, that is until the end of the program, hence the `'static`\n  lifetime.\n- The [`Send`] constraint is because the closure will need to be passed\n  *by value* from the thread where it is spawned to the new thread. Its\n  return value will need to be passed from the new thread to the thread\n  where it is `join`ed.\n  As a reminder, the [`Send`] marker trait expresses that it is safe to be\n  passed from thread to thread. [`Sync`] expresses that it is safe to have a\n  reference be passed from thread to thread.\n\n# Panics\n\nPanics if the OS fails to create a thread; use [`Builder::spawn`]\nto recover from such errors.\n\n# Examples\n\nCreating a thread.\n\n```rust\nuse std::thread;\n\nlet handler = thread::spawn(|| {\n    // thread code\n});\n\nhandler.join().unwrap();\n```\n\nAs mentioned in the module documentation, threads are usually made to\ncommunicate using [`channels`], here is how it usually looks.\n\nThis example also shows how to use `move`, in order to give ownership\nof values to a thread.\n\n```rust\nuse std::thread;\nuse std::sync::mpsc::channel;\n\nlet (tx, rx) = channel();\n\nlet sender = thread::spawn(move || {\n    tx.send(\"Hello, thread\".to_owned())\n        .expect(\"Unable to send on channel\");\n});\n\nlet receiver = thread::spawn(move || {\n    let value = rx.recv().expect(\"Unable to receive from channel\");\n    println!(\"{}\", value);\n});\n\nsender.join().expect(\"The sender thread has panicked\");\nreceiver.join().expect(\"The receiver thread has panicked\");\n```\n\nA thread can also return a value through its [`JoinHandle`], you can use\nthis to make asynchronous computations (futures might be more appropriate\nthough).\n\n```rust\nuse std::thread;\n\nlet computation = thread::spawn(|| {\n    // Some expensive computation.\n    42\n});\n\nlet result = computation.join().unwrap();\nprintln!(\"{}\", result);\n```\n\n[`channels`]: ../../std/sync/mpsc/index.html\n[`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n[`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n[`Err`]: ../../std/result/enum.Result.html#variant.Err\n[`panic`]: ../../std/macro.panic.html\n[`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n[`Builder`]: ../../std/thread/struct.Builder.html\n[`Send`]: ../../std/marker/trait.Send.html\n[`Sync`]: ../../std/marker/trait.Sync.html"
    ]
  }
}