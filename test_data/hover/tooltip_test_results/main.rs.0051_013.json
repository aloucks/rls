{
  "test": {
    "file": "main.rs",
    "line": 51,
    "col": 13
  },
  "data": {
    "Ok": [
      "Native threads.\n\n## The threading model\n\nAn executing Rust program consists of a collection of native OS threads,\neach with their own stack and local state. Threads can be named, and\nprovide some built-in support for low-level synchronization.\n\nCommunication between threads can be done through\n[channels], Rust's message-passing types, along with [other forms of thread\nsynchronization](../../std/sync/index.html) and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, [`Arc`].\n\nFatal logic errors in Rust cause *thread panic*, during which\na thread will unwind the stack, running destructors and freeing\nowned resources. While not meant as a 'try/catch' mechanism, panics\nin Rust can nonetheless be caught (unless compiling with `panic=abort`) with\n[`catch_unwind`](../../std/panic/fn.catch_unwind.html) and recovered\nfrom, or alternatively be resumed with\n[`resume_unwind`](../../std/panic/fn.resume_unwind.html). If the panic\nis not caught the thread will exit, but the panic may optionally be\ndetected from a different thread with [`join`]. If the main thread panics\nwithout the panic being caught, the application will exit with a\nnon-zero exit code.\n\nWhen the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nchild thread (i.e., join).\n\n## Spawning a thread\n\nA new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n\n```rust\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\nIn this example, the spawned thread is \"detached\" from the current\nthread. This means that it can outlive its parent (the thread that spawned\nit), unless this parent is the main thread.\n\nThe parent thread can also wait on the completion of the child\nthread; a call to [`spawn`] produces a [`JoinHandle`], which provides\na `join` method for waiting:\n\n```rust\nuse std::thread;\n\nlet child = thread::spawn(move || {\n    // some work here\n});\n// some work here\nlet res = child.join();\n```\n\nThe [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\nvalue produced by the child thread, or [`Err`] of the value given to\na call to [`panic!`] if the child panicked.\n\n## Configuring threads\n\nA new thread can be configured before it is spawned via the [`Builder`] type,\nwhich currently allows you to set the name and stack size for the child thread:\n\n```rust\nuse std::thread;\n\nthread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n    println!(\"Hello, world!\");\n});\n```\n\n## The `Thread` type\n\nThreads are represented via the [`Thread`] type, which you can get in one of\ntwo ways:\n\n* By spawning a new thread, e.g. using the [`thread::spawn`][`spawn`]\n  function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n* By requesting the current thread, using the [`thread::current`] function.\n\nThe [`thread::current`] function is available even for threads not spawned\nby the APIs of this module.\n\n## Thread-local storage\n\nThis module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of.\nThreads do not share this data, so accesses do not need to be synchronized.\n\nA thread-local key owns the value it contains and will destroy the value when the\nthread exits. It is created with the [`thread_local!`] macro and can contain any\nvalue that is `'static` (no borrowed pointers). It provides an accessor function,\n[`with`], that yields a shared reference to the value to the specified\nclosure. Thread-local keys allow only shared access to values, as there would be no\nway to guarantee uniqueness if mutable borrows were allowed. Most values\nwill want to make use of some form of **interior mutability** through the\n[`Cell`] or [`RefCell`] types.\n\n## Naming threads\n\nThreads are able to have associated names for identification purposes. By default, spawned\nthreads are unnamed. To specify a name for a thread, build the thread with [`Builder`] and pass\nthe desired thread name to [`Builder::name`]. To retrieve the thread name from within the\nthread, use [`Thread::name`]. A couple examples of where the name of a thread gets used:\n\n* If a panic occurs in a named thread, the thread name will be printed in the panic message.\n* The thread name is provided to the OS where applicable (e.g. `pthread_setname_np` in\n  unix-like platforms).\n\n## Stack size\n\nThe default stack size for spawned threads is 2 MiB, though this particular stack size is\nsubject to change in the future. There are two ways to manually specify the stack size for\nspawned threads:\n\n* Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n* Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\n  size (in bytes). Note that setting [`Builder::stack_size`] will override this.\n\nNote that the stack size of the main thread is *not* determined by Rust.\n\n[channels]: ../../std/sync/mpsc/index.html\n[`Arc`]: ../../std/sync/struct.Arc.html\n[`spawn`]: ../../std/thread/fn.spawn.html\n[`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n[`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n[`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n[`Result`]: ../../std/result/enum.Result.html\n[`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n[`Err`]: ../../std/result/enum.Result.html#variant.Err\n[`panic!`]: ../../std/macro.panic.html\n[`Builder`]: ../../std/thread/struct.Builder.html\n[`Builder::stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n[`Builder::name`]: ../../std/thread/struct.Builder.html#method.name\n[`thread::current`]: ../../std/thread/fn.current.html\n[`thread::Result`]: ../../std/thread/type.Result.html\n[`Thread`]: ../../std/thread/struct.Thread.html\n[`park`]: ../../std/thread/fn.park.html\n[`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n[`Thread::name`]: ../../std/thread/struct.Thread.html#method.name\n[`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n[`Cell`]: ../cell/struct.Cell.html\n[`RefCell`]: ../cell/struct.RefCell.html\n[`thread_local!`]: ../macro.thread_local.html\n[`with`]: struct.LocalKey.html#method.with"
    ]
  }
}