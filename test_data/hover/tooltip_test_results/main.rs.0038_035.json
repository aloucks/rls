{
  "test": {
    "file": "main.rs",
    "line": 38,
    "col": 35
  },
  "data": {
    "Ok": [
      {
        "language": "rust",
        "value": "pub struct Vec<T>"
      },
      "https://doc.rust-lang.org/nightly/alloc/vec/Vec.t.html",
      "A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n\n# Examples\n\n```rust\nlet mut vec = Vec::new();\nvec.push(1);\nvec.push(2);\n\nassert_eq!(vec.len(), 2);\nassert_eq!(vec[0], 1);\n\nassert_eq!(vec.pop(), Some(2));\nassert_eq!(vec.len(), 1);\n\nvec[0] = 7;\nassert_eq!(vec[0], 7);\n\nvec.extend([1, 2, 3].iter().cloned());\n\nfor x in &vec {\n    println!(\"{}\", x);\n}\nassert_eq!(vec, [7, 1, 2, 3]);\n```\n\nThe [`vec!`] macro is provided to make initialization more convenient:\n\n```rust\nlet mut vec = vec![1, 2, 3];\nvec.push(4);\nassert_eq!(vec, [1, 2, 3, 4]);\n```\n\nIt can also initialize each element of a `Vec<T>` with a given value:\n\n```rust\nlet vec = vec![0; 5];\nassert_eq!(vec, [0, 0, 0, 0, 0]);\n```\n\nUse a `Vec<T>` as an efficient stack:\n\n```rust\nlet mut stack = Vec::new();\n\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\nwhile let Some(top) = stack.pop() {\n    // Prints 3, 2, 1\n    println!(\"{}\", top);\n}\n```\n\n# Indexing\n\nThe `Vec` type allows to access values by index, because it implements the\n[`Index`] trait. An example will be more explicit:\n\n```rust\nlet v = vec![0, 2, 4, 6];\nprintln!(\"{}\", v[1]); // it will display '2'\n```\n\nHowever be careful: if you try to access an index which isn't in the `Vec`,\nyour software will panic! You cannot do this:\n\n```rust\nlet v = vec![0, 2, 4, 6];\nprintln!(\"{}\", v[6]); // it will panic!\n```\n\nIn conclusion: always check if the index you want to get really exists\nbefore doing it.\n\n# Slicing\n\nA `Vec` can be mutable. Slices, on the other hand, are read-only objects.\nTo get a slice, use `&`. Example:\n\n```rust\nfn read_slice(slice: &[usize]) {\n    // ...\n}\n\nlet v = vec![0, 1];\nread_slice(&v);\n\n// ... and that's all!\n// you can also do it like this:\nlet x : &[usize] = &v;\n```\n\nIn Rust, it's more common to pass slices as arguments rather than vectors\nwhen you just want to provide a read access. The same goes for [`String`] and\n[`&str`].\n\n# Capacity and reallocation\n\nThe capacity of a vector is the amount of space allocated for any future\nelements that will be added onto the vector. This is not to be confused with\nthe *length* of a vector, which specifies the number of actual elements\nwithin the vector. If a vector's length exceeds its capacity, its capacity\nwill automatically be increased, but its elements will have to be\nreallocated.\n\nFor example, a vector with capacity 10 and length 0 would be an empty vector\nwith space for 10 more elements. Pushing 10 or fewer elements onto the\nvector will not change its capacity or cause reallocation to occur. However,\nif the vector's length is increased to 11, it will have to reallocate, which\ncan be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\nwhenever possible to specify how big the vector is expected to get.\n\n# Guarantees\n\nDue to its incredibly fundamental nature, `Vec` makes a lot of guarantees\nabout its design. This ensures that it's as low-overhead as possible in\nthe general case, and can be correctly manipulated in primitive ways\nby unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\nIf additional type parameters are added (e.g. to support custom allocators),\noverriding their defaults may change the behavior.\n\nMost fundamentally, `Vec` is and always will be a (pointer, capacity, length)\ntriplet. No more, no less. The order of these fields is completely\nunspecified, and you should use the appropriate methods to modify these.\nThe pointer will never be null, so this type is null-pointer-optimized.\n\nHowever, the pointer may not actually point to allocated memory. In particular,\nif you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n[`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\non an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\ntypes inside a `Vec`, it will not allocate space for them. *Note that in this case\nthe `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\nif [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\ndetails are very subtle &mdash; if you intend to allocate memory using a `Vec`\nand use it for something else (either to pass to unsafe code, or to build your\nown memory-backed collection), be sure to deallocate this memory by using\n`from_raw_parts` to recover the `Vec` and then dropping it.\n\nIf a `Vec` *has* allocated memory, then the memory it points to is on the heap\n(as defined by the allocator Rust is configured to use by default), and its\npointer points to [`len`] initialized, contiguous elements in order (what\nyou would see if you coerced it to a slice), followed by [`capacity`]` -\n`[`len`] logically uninitialized, contiguous elements.\n\n`Vec` will never perform a \"small optimization\" where elements are actually\nstored on the stack for two reasons:\n\n* It would make it more difficult for unsafe code to correctly manipulate\n  a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n  only moved, and it would be more difficult to determine if a `Vec` had\n  actually allocated memory.\n\n* It would penalize the general case, incurring an additional branch\n  on every access.\n\n`Vec` will never automatically shrink itself, even if completely empty. This\nensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\nand then filling it back up to the same [`len`] should incur no calls to\nthe allocator. If you wish to free up unused memory, use\n[`shrink_to_fit`][`shrink_to_fit`].\n\n[`push`] and [`insert`] will never (re)allocate if the reported capacity is\nsufficient. [`push`] and [`insert`] *will* (re)allocate if\n[`len`]` == `[`capacity`]. That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\nwhen not necessary.\n\n`Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`] is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee `O(1)` amortized [`push`].\n\n`vec![x; n]`, `vec![a, b, c, d]`, and\n[`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\nwith exactly the requested capacity. If [`len`]` == `[`capacity`],\n(as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\nand from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n\n`Vec` will not specifically overwrite any data that is removed from it,\nbut also won't specifically preserve it. Its uninitialized memory is\nscratch space that it may use however it wants. It will generally just do\nwhatever is most efficient or otherwise easy to implement. Do not rely on\nremoved data to be erased for security purposes. Even if you drop a `Vec`, its\nbuffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\nfirst, that may not actually happen because the optimizer does not consider\nthis a side-effect that must be preserved. There is one case which we will\nnot break, however: using `unsafe` code to write to the excess capacity,\nand then increasing the length to match, is always valid.\n\n`Vec` does not currently guarantee the order in which elements are dropped.\nThe order has changed in the past and may change again.\n\n[`vec!`]: ../../std/macro.vec.html\n[`Index`]: ../../std/ops/trait.Index.html\n[`String`]: ../../std/string/struct.String.html\n[`&str`]: ../../std/primitive.str.html\n[`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n[`Vec::new`]: ../../std/vec/struct.Vec.html#method.new\n[`shrink_to_fit`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n[`capacity`]: ../../std/vec/struct.Vec.html#method.capacity\n[`mem::size_of::<T>`]: ../../std/mem/fn.size_of.html\n[`len`]: ../../std/vec/struct.Vec.html#method.len\n[`push`]: ../../std/vec/struct.Vec.html#method.push\n[`insert`]: ../../std/vec/struct.Vec.html#method.insert\n[`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n[owned slice]: ../../std/boxed/struct.Box.html"
    ]
  }
}