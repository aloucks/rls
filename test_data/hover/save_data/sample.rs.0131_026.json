{
  "test": {
    "file": "sample.rs",
    "line": 131,
    "col": 26
  },
  "data": {
    "Ok": [
      {
        "language": "rust",
        "value": "pub struct HashMap<K, V, S = RandomState>"
      },
      "https://doc.rust-lang.org/nightly/std/collections/hash/map/HashMap.t.html",
      "A hash map implemented with linear probing and Robin Hood bucket stealing.\n\nBy default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks. The algorithm is randomly seeded, and a\nreasonable best-effort is made to generate this seed from a high quality,\nsecure source of randomness provided by the host without blocking the\nprogram. Because of this, the randomness of the seed depends on the output\nquality of the system's random number generator when the seed is created.\nIn particular, seeds generated when the system's entropy pool is abnormally\nlow such as during system boot may be of a lower quality.\n\nThe default hashing algorithm is currently SipHash 1-3, though this is\nsubject to change at any point in the future. While its performance is very\ncompetitive for medium sized keys, other hashing algorithms will outperform\nit for small keys such as integers as well as large keys such as long\nstrings, though those algorithms will typically *not* protect against\nattacks such as HashDoS.\n\nThe hashing algorithm can be replaced on a per-`HashMap` basis using the\n[`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\nalternative algorithms are available on crates.io, such as the [`fnv`] crate.\n\nIt is required that the keys implement the [`Eq`] and [`Hash`] traits, although\nthis can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\nIf you implement these yourself, it is important that the following\nproperty holds:\n\n```text\nk1 == k2 -> hash(k1) == hash(k2)\n```\n\nIn other words, if two keys are equal, their hashes must be equal.\n\nIt is a logic error for a key to be modified in such a way that the key's\nhash, as determined by the [`Hash`] trait, or its equality, as determined by\nthe [`Eq`] trait, changes while it is in the map. This is normally only\npossible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n\nRelevant papers/articles:\n\n1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n2. Emmanuel Goossaert. [\"Robin Hood\n   hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n   deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n\n# Examples\n\n```rust\nuse std::collections::HashMap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `HashMap<String, String>` in this example).\nlet mut book_reviews = HashMap::new();\n\n// Review some books.\nbook_reviews.insert(\n    \"Adventures of Huckleberry Finn\".to_string(),\n    \"My favorite book.\".to_string(),\n);\nbook_reviews.insert(\n    \"Grimms' Fairy Tales\".to_string(),\n    \"Masterpiece.\".to_string(),\n);\nbook_reviews.insert(\n    \"Pride and Prejudice\".to_string(),\n    \"Very enjoyable.\".to_string(),\n);\nbook_reviews.insert(\n    \"The Adventures of Sherlock Holmes\".to_string(),\n    \"Eye lyked it alot.\".to_string(),\n);\n\n// Check for a specific one.\n// When collections store owned values (String), they can still be\n// queried using references (&str).\nif !book_reviews.contains_key(\"Les Misérables\") {\n    println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n             book_reviews.len());\n}\n\n// oops, this review has a lot of spelling mistakes, let's delete it.\nbook_reviews.remove(\"The Adventures of Sherlock Holmes\");\n\n// Look up the values associated with some keys.\nlet to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\nfor &book in &to_find {\n    match book_reviews.get(book) {\n        Some(review) => println!(\"{}: {}\", book, review),\n        None => println!(\"{} is unreviewed.\", book)\n    }\n}\n\n// Iterate over everything.\nfor (book, review) in &book_reviews {\n    println!(\"{}: \\\"{}\\\"\", book, review);\n}\n```\n\n`HashMap` also implements an [`Entry API`](#method.entry), which allows\nfor more complex methods of getting, setting, updating and removing keys and\ntheir values:\n\n```rust\nuse std::collections::HashMap;\n\n// type inference lets us omit an explicit type signature (which\n// would be `HashMap<&str, u8>` in this example).\nlet mut player_stats = HashMap::new();\n\nfn random_stat_buff() -> u8 {\n    // could actually return some random value here - let's just return\n    // some fixed value for now\n    42\n}\n\n// insert a key only if it doesn't already exist\nplayer_stats.entry(\"health\").or_insert(100);\n\n// insert a key using a function that provides a new value only if it\n// doesn't already exist\nplayer_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n\n// update a key, guarding against the key possibly not being set\nlet stat = player_stats.entry(\"attack\").or_insert(100);\n*stat += random_stat_buff();\n```\n\nThe easiest way to use `HashMap` with a custom type as key is to derive [`Eq`] and [`Hash`].\nWe must also derive [`PartialEq`].\n\n[`Eq`]: ../../std/cmp/trait.Eq.html\n[`Hash`]: ../../std/hash/trait.Hash.html\n[`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n[`RefCell`]: ../../std/cell/struct.RefCell.html\n[`Cell`]: ../../std/cell/struct.Cell.html\n[`default`]: #method.default\n[`with_hasher`]: #method.with_hasher\n[`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n[`fnv`]: https://crates.io/crates/fnv\n\n```rust\nuse std::collections::HashMap;\n\n#[derive(Hash, Eq, PartialEq, Debug)]\nstruct Viking {\n    name: String,\n    country: String,\n}\n\nimpl Viking {\n    /// Create a new Viking.\n    fn new(name: &str, country: &str) -> Viking {\n        Viking { name: name.to_string(), country: country.to_string() }\n    }\n}\n\n// Use a HashMap to store the vikings' health points.\nlet mut vikings = HashMap::new();\n\nvikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\nvikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\nvikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n\n// Use derived implementation to print the status of the vikings.\nfor (viking, health) in &vikings {\n    println!(\"{:?} has {} hp\", viking, health);\n}\n```\n\nA `HashMap` with fixed list of elements can be initialized from an array:\n\n```rust\nuse std::collections::HashMap;\n\nfn main() {\n    let timber_resources: HashMap<&str, i32> =\n    [(\"Norway\", 100),\n     (\"Denmark\", 50),\n     (\"Iceland\", 10)]\n     .iter().cloned().collect();\n    // use the values stored in map\n}\n```"
    ]
  }
}