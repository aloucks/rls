{
  "test": {
    "file": "sample.rs",
    "line": 131,
    "col": 14
  },
  "data": {
    "Ok": [
      "Collection types.\n\nRust's standard collection library provides efficient implementations of the\nmost common general purpose programming data structures. By using the\nstandard implementations, it should be possible for two libraries to\ncommunicate without significant data conversion.\n\nTo get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\nThese two collections cover most use cases for generic data storage and\nprocessing. They are exceptionally good at doing what they do. All the other\ncollections in the standard library have specific use cases where they are\nthe optimal choice, but these cases are borderline *niche* in comparison.\nEven when `Vec` and `HashMap` are technically suboptimal, they're probably a\ngood enough choice to get started.\n\nRust's collections can be grouped into four major categories:\n\n* Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n* Maps: [`HashMap`], [`BTreeMap`]\n* Sets: [`HashSet`], [`BTreeSet`]\n* Misc: [`BinaryHeap`]\n\n# When Should You Use Which Collection?\n\nThese are fairly high-level and quick break-downs of when each collection\nshould be considered. Detailed discussions of strengths and weaknesses of\nindividual collections can be found on their own documentation pages.\n\n### Use a `Vec` when:\n* You want to collect items up to be processed or sent elsewhere later, and\n  don't care about any properties of the actual values being stored.\n* You want a sequence of elements in a particular order, and will only be\n  appending to (or near) the end.\n* You want a stack.\n* You want a resizable array.\n* You want a heap-allocated array.\n\n### Use a `VecDeque` when:\n* You want a [`Vec`] that supports efficient insertion at both ends of the\n  sequence.\n* You want a queue.\n* You want a double-ended queue (deque).\n\n### Use a `LinkedList` when:\n* You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n  amortization.\n* You want to efficiently split and append lists.\n* You are *absolutely* certain you *really*, *truly*, want a doubly linked\n  list.\n\n### Use a `HashMap` when:\n* You want to associate arbitrary keys with an arbitrary value.\n* You want a cache.\n* You want a map, with no extra functionality.\n\n### Use a `BTreeMap` when:\n* You want a map sorted by its keys.\n* You want to be able to get a range of entries on-demand.\n* You're interested in what the smallest or largest key-value pair is.\n* You want to find the largest or smallest key that is smaller or larger\n  than something.\n\n### Use the `Set` variant of any of these `Map`s when:\n* You just want to remember which keys you've seen.\n* There is no meaningful value to associate with your keys.\n* You just want a set.\n\n### Use a `BinaryHeap` when:\n\n* You want to store a bunch of elements, but only ever want to process the\n  \"biggest\" or \"most important\" one at any given time.\n* You want a priority queue.\n\n# Performance\n\nChoosing the right collection for the job requires an understanding of what\neach collection is good at. Here we briefly summarize the performance of\ndifferent collections for certain important operations. For further details,\nsee each type's documentation, and note that the names of actual methods may\ndiffer from the tables below on certain collections.\n\nThroughout the documentation, we will follow a few conventions. For all\noperations, the collection's size is denoted by n. If another collection is\ninvolved in the operation, it contains m elements. Operations which have an\n*amortized* cost are suffixed with a `*`. Operations with an *expected*\ncost are suffixed with a `~`.\n\nAll amortized costs are for the potential need to resize when capacity is\nexhausted. If a resize occurs it will take O(n) time. Our collections never\nautomatically shrink, so removal operations aren't amortized. Over a\nsufficiently large series of operations, the average cost per operation will\ndeterministically equal the given cost.\n\nOnly [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\nIt is theoretically possible, though very unlikely, for [`HashMap`] to\nexperience worse performance.\n\n## Sequences\n\n|                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n|----------------|----------------|-----------------|----------------|--------|----------------|\n| [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n| [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n| [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n\nNote that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n[`VecDeque`] is generally going to be faster than [`LinkedList`].\n\n## Maps\n\nFor Sets, all operations have the cost of the equivalent Map operation.\n\n|              | get       | insert   | remove   | predecessor | append |\n|--------------|-----------|----------|----------|-------------|--------|\n| [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n| [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n\n# Correct and Efficient Usage of Collections\n\nOf course, knowing which collection is the right one for the job doesn't\ninstantly permit you to use it correctly. Here are some quick tips for\nefficient and correct usage of the standard collections in general. If\nyou're interested in how to use a specific collection in particular, consult\nits documentation for detailed discussion and code examples.\n\n## Capacity Management\n\nMany collections provide several constructors and methods that refer to\n\"capacity\". These collections are generally built on top of an array.\nOptimally, this array would be exactly the right size to fit only the\nelements stored in the collection, but for the collection to do this would\nbe very inefficient. If the backing array was exactly the right size at all\ntimes, then every time an element is inserted, the collection would have to\ngrow the array to fit it. Due to the way memory is allocated and managed on\nmost computers, this would almost surely require allocating an entirely new\narray and copying every single element from the old one into the new one.\nHopefully you can see that this wouldn't be very efficient to do on every\noperation.\n\nMost collections therefore use an *amortized* allocation strategy. They\ngenerally let themselves have a fair amount of unoccupied space so that they\nonly have to grow on occasion. When they do grow, they allocate a\nsubstantially larger array to move the elements into so that it will take a\nwhile for another grow to be required. While this strategy is great in\ngeneral, it would be even better if the collection *never* had to resize its\nbacking array. Unfortunately, the collection itself doesn't have enough\ninformation to do this itself. Therefore, it is up to us programmers to give\nit hints.\n\nAny `with_capacity` constructor will instruct the collection to allocate\nenough space for the specified number of elements. Ideally this will be for\nexactly that many elements, but some implementation details may prevent\nthis. [`Vec`] and [`VecDeque`] can be relied on to allocate exactly the\nrequested amount, though. Use `with_capacity` when you know exactly how many\nelements will be inserted, or at least have a reasonable upper-bound on that\nnumber.\n\nWhen anticipating a large influx of elements, the `reserve` family of\nmethods can be used to hint to the collection how much room it should make\nfor the coming items. As with `with_capacity`, the precise behavior of\nthese methods will be specific to the collection of interest.\n\nFor optimal performance, collections will generally avoid shrinking\nthemselves. If you believe that a collection will not soon contain any more\nelements, or just really need the memory, the `shrink_to_fit` method prompts\nthe collection to shrink the backing array to the minimum size capable of\nholding its elements.\n\nFinally, if ever you're interested in what the actual capacity of the\ncollection is, most collections provide a `capacity` method to query this\ninformation on demand. This can be useful for debugging purposes, or for\nuse with the `reserve` methods.\n\n## Iterators\n\nIterators are a powerful and robust mechanism used throughout Rust's\nstandard libraries. Iterators provide a sequence of values in a generic,\nsafe, efficient and convenient way. The contents of an iterator are usually\n*lazily* evaluated, so that only the values that are actually needed are\never actually produced, and no allocation need be done to temporarily store\nthem. Iterators are primarily consumed using a `for` loop, although many\nfunctions also take iterators where a collection or sequence of values is\ndesired.\n\nAll of the standard collections provide several iterators for performing\nbulk manipulation of their contents. The three primary iterators almost\nevery collection should provide are `iter`, `iter_mut`, and `into_iter`.\nSome of these are not provided on collections where it would be unsound or\nunreasonable to provide them.\n\n`iter` provides an iterator of immutable references to all the contents of a\ncollection in the most \"natural\" order. For sequence collections like [`Vec`],\nthis means the items will be yielded in increasing order of index starting\nat 0. For ordered collections like [`BTreeMap`], this means that the items\nwill be yielded in sorted order. For unordered collections like [`HashMap`],\nthe items will be yielded in whatever order the internal representation made\nmost convenient. This is great for reading through all the contents of the\ncollection.\n\n```rust\nlet vec = vec![1, 2, 3, 4];\nfor x in vec.iter() {\n   println!(\"vec contained {}\", x);\n}\n```\n\n`iter_mut` provides an iterator of *mutable* references in the same order as\n`iter`. This is great for mutating all the contents of the collection.\n\n```rust\nlet mut vec = vec![1, 2, 3, 4];\nfor x in vec.iter_mut() {\n   *x += 1;\n}\n```\n\n`into_iter` transforms the actual collection into an iterator over its\ncontents by-value. This is great when the collection itself is no longer\nneeded, and the values are needed elsewhere. Using `extend` with `into_iter`\nis the main way that contents of one collection are moved into another.\n`extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\nCalling `collect` on an iterator itself is also a great way to convert one\ncollection into another. Both of these methods should internally use the\ncapacity management tools discussed in the previous section to do this as\nefficiently as possible.\n\n```rust\nlet mut vec1 = vec![1, 2, 3, 4];\nlet vec2 = vec![10, 20, 30, 40];\nvec1.extend(vec2);\n```\n\n```rust\nuse std::collections::VecDeque;\n\nlet vec = vec![1, 2, 3, 4];\nlet buf: VecDeque<_> = vec.into_iter().collect();\n```\n\nIterators also provide a series of *adapter* methods for performing common\nthreads to sequences. Among the adapters are functional favorites like `map`,\n`fold`, `skip` and `take`. Of particular interest to collections is the\n`rev` adapter, that reverses any iterator that supports this operation. Most\ncollections provide reversible iterators as the way to iterate over them in\nreverse order.\n\n```rust\nlet vec = vec![1, 2, 3, 4];\nfor x in vec.iter().rev() {\n   println!(\"vec contained {}\", x);\n}\n```\n\nSeveral other collection methods also return iterators to yield a sequence\nof results but avoid allocating an entire collection to store the result in.\nThis provides maximum flexibility as `collect` or `extend` can be called to\n\"pipe\" the sequence into any collection if desired. Otherwise, the sequence\ncan be looped over with a `for` loop. The iterator can also be discarded\nafter partial use, preventing the computation of the unused items.\n\n## Entries\n\nThe `entry` API is intended to provide an efficient mechanism for\nmanipulating the contents of a map conditionally on the presence of a key or\nnot. The primary motivating use case for this is to provide efficient\naccumulator maps. For instance, if one wishes to maintain a count of the\nnumber of times each key has been seen, they will have to perform some\nconditional logic on whether this is the first time the key has been seen or\nnot. Normally, this would require a `find` followed by an `insert`,\neffectively duplicating the search effort on each insertion.\n\nWhen a user calls `map.entry(&key)`, the map will search for the key and\nthen yield a variant of the `Entry` enum.\n\nIf a `Vacant(entry)` is yielded, then the key *was not* found. In this case\nthe only valid operation is to `insert` a value into the entry. When this is\ndone, the vacant entry is consumed and converted into a mutable reference to\nthe value that was inserted. This allows for further manipulation of the\nvalue beyond the lifetime of the search itself. This is useful if complex\nlogic needs to be performed on the value regardless of whether the value was\njust inserted.\n\nIf an `Occupied(entry)` is yielded, then the key *was* found. In this case,\nthe user has several options: they can `get`, `insert` or `remove` the\nvalue of the occupied entry. Additionally, they can convert the occupied\nentry into a mutable reference to its value, providing symmetry to the\nvacant `insert` case.\n\n### Examples\n\nHere are the two primary ways in which `entry` is used. First, a simple\nexample where the logic performed on the values is trivial.\n\n#### Counting the number of times each character in a string occurs\n\n```rust\nuse std::collections::btree_map::BTreeMap;\n\nlet mut count = BTreeMap::new();\nlet message = \"she sells sea shells by the sea shore\";\n\nfor c in message.chars() {\n    *count.entry(c).or_insert(0) += 1;\n}\n\nassert_eq!(count.get(&'s'), Some(&8));\n\nprintln!(\"Number of occurrences of each character\");\nfor (char, count) in &count {\n    println!(\"{}: {}\", char, count);\n}\n```\n\nWhen the logic to be performed on the value is more complex, we may simply\nuse the `entry` API to ensure that the value is initialized and perform the\nlogic afterwards.\n\n#### Tracking the inebriation of customers at a bar\n\n```rust\nuse std::collections::btree_map::BTreeMap;\n\n// A client of the bar. They have a blood alcohol level.\nstruct Person { blood_alcohol: f32 }\n\n// All the orders made to the bar, by client id.\nlet orders = vec![1,2,1,2,3,4,1,2,2,3,4,1,1,1];\n\n// Our clients.\nlet mut blood_alcohol = BTreeMap::new();\n\nfor id in orders {\n    // If this is the first time we've seen this customer, initialize them\n    // with no blood alcohol. Otherwise, just retrieve them.\n    let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\n\n    // Reduce their blood alcohol level. It takes time to order and drink a beer!\n    person.blood_alcohol *= 0.9;\n\n    // Check if they're sober enough to have another beer.\n    if person.blood_alcohol > 0.3 {\n        // Too drunk... for now.\n        println!(\"Sorry {}, I have to cut you off\", id);\n    } else {\n        // Have another!\n        person.blood_alcohol += 0.1;\n    }\n}\n```\n\n# Insert and complex keys\n\nIf we have a more complex key, calls to `insert` will\nnot update the value of the key. For example:\n\n```rust\nuse std::cmp::Ordering;\nuse std::collections::BTreeMap;\nuse std::hash::{Hash, Hasher};\n\n#[derive(Debug)]\nstruct Foo {\n    a: u32,\n    b: &'static str,\n}\n\n// we will compare `Foo`s by their `a` value only.\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool { self.a == other.a }\n}\n\nimpl Eq for Foo {}\n\n// we will hash `Foo`s by their `a` value only.\nimpl Hash for Foo {\n    fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\n}\n\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\n}\n\nimpl Ord for Foo {\n    fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\n}\n\nlet mut map = BTreeMap::new();\nmap.insert(Foo { a: 1, b: \"baz\" }, 99);\n\n// We already have a Foo with an a of 1, so this will be updating the value.\nmap.insert(Foo { a: 1, b: \"xyz\" }, 100);\n\n// The value has been updated...\nassert_eq!(map.values().next().unwrap(), &100);\n\n// ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\nassert_eq!(map.keys().next().unwrap().b, \"baz\");\n```\n\n[`Vec`]: ../../std/vec/struct.Vec.html\n[`HashMap`]: ../../std/collections/struct.HashMap.html\n[`VecDeque`]: ../../std/collections/struct.VecDeque.html\n[`LinkedList`]: ../../std/collections/struct.LinkedList.html\n[`BTreeMap`]: ../../std/collections/struct.BTreeMap.html\n[`HashSet`]: ../../std/collections/struct.HashSet.html\n[`BTreeSet`]: ../../std/collections/struct.BTreeSet.html\n[`BinaryHeap`]: ../../std/collections/struct.BinaryHeap.html\n[`IntoIterator`]: ../../std/iter/trait.IntoIterator.html"
    ]
  }
}